use arcstr::ArcStr;
use arrayvec::ArrayVec;
use ascii::AsciiString;
use color_eyre::eyre::{eyre, Context};
use eio::ReadExt;
use std::{fmt::Display, io::BufRead};

/// An ABI list parsed from a consolidated `abilists` data generated by [`glibc-abi-tool`].
///
/// [`glibc-abi-tool`]: https://github.com/ziglang/glibc-abi-tool/
pub struct AbiList {
    lib_names: ArrayVec<ArcStr, 8>,
    versions: ArrayVec<GlibcVersion, 64>,
    targets: ArrayVec<ArcStr, 32>,
    functions: Vec<Function>,
}

// TODO
// /// An error case that may happen in [`AbiList::from_bytes`].
// #[derive(Debug, thiserror::Error)]
// pub enum AbiListParseError {}

pub type AbiListParseError = color_eyre::eyre::Error;

impl AbiList {
    pub fn from_reader(mut reader: &mut dyn BufRead) -> Result<Self, AbiListParseError> {
        let lib_names = {
            let mut lib_names = ArrayVec::<ArcStr, 8>::new();
            let num_lib_names: u8 = reader
                .read_le()
                .wrap_err("failed to read number of library names")?;
            for idx in 0..num_lib_names {
                macro_rules! this_elem_disp {
                    () => {
                        format_args!("element {idx} of library names array")
                    };
                }
                let lib_name = parse_nul_term_ascii(&mut reader, &this_elem_disp!())
                    .wrap_err_with(|| {
                        eyre!("failed to read element {idx} of library names array")
                    })?;
                let lib_name: String = lib_name.into();
                lib_names.push(ArcStr::from(lib_name));
            }
            lib_names
        };

        let versions = {
            let mut versions = ArrayVec::<GlibcVersion, 64>::new();
            let num_versions: u8 = reader
                .read_le()
                .wrap_err("failed to read number of supported `glibc` versions")?;
            for idx in 0..num_versions {
                let mut parse = |what| {
                    reader.read_le().wrap_err_with(|| {
                        eyre!(
                            "failed to read {what} field of element {idx} of supported `glibc` \
                            versions array"
                        )
                    })
                };
                let major = parse("major")?;
                let minor = parse("minor")?;
                let patch = parse("patch")?;
                versions.push(GlibcVersion {
                    major,
                    minor,
                    patch,
                });
            }
            versions
        };

        let targets = {
            let mut targets = ArrayVec::<ArcStr, 32>::new();

            let num_targets: u8 = reader
                .read_le()
                .wrap_err("failed to read number of target triples")?;

            for idx in 0..num_targets {
                macro_rules! this_elem_disp {
                    () => {
                        format_args!("element {idx} of target triples array")
                    };
                }
                let target = parse_nul_term_ascii(&mut reader, &this_elem_disp!())?;
                let target: String = target.into();
                let target = ArcStr::from(target);
                targets.push(target);
            }

            targets
        };

        let functions = {
            let mut functions = Vec::new();

            let disallowed_target_triple_bitmask = (!0u32) << targets.len();

            let mut num_inclusions_found = 0;
            let mut num_functions_found = 0;
            let num_function_inclusions = reader
                .read_le::<u16>()
                .wrap_err("failed to read number of functions")?;

            while num_inclusions_found < num_function_inclusions {
                macro_rules! this_elem_disp {
                    () => {
                        format_args!("element {num_functions_found} of functions array")
                    };
                }

                let symbol_name = parse_nul_term_ascii(
                    &mut reader,
                    &format_args!("symbol name of {}", this_elem_disp!()),
                )?;
                let symbol_name: String = symbol_name.into();
                let symbol_name = ArcStr::from(symbol_name);

                log::debug!("found symbol with name `{symbol_name}`");

                macro_rules! this_func_disp {
                    () => {
                        format_args!("function `{symbol_name}`, ({})", this_elem_disp!(),)
                    };
                }

                let mut inclusions = Vec::new();
                let mut is_last_inclusion_for_symbol_name = false;
                while !is_last_inclusion_for_symbol_name {
                    const LAST_INCLUSION_FOR_SYMBOL_NAME_BITMASK: u32 = !(!0 >> 1);

                    let mut targets_bitmask = reader.read_le::<u32>().wrap_err_with(|| {
                        eyre!("failed to read target bitmask of {}", this_func_disp!())
                    })?;

                    is_last_inclusion_for_symbol_name =
                        targets_bitmask & LAST_INCLUSION_FOR_SYMBOL_NAME_BITMASK != 0;
                    if is_last_inclusion_for_symbol_name {
                        targets_bitmask &= !LAST_INCLUSION_FOR_SYMBOL_NAME_BITMASK;
                    }

                    if targets_bitmask & disallowed_target_triple_bitmask != 0 {
                        return Err(eyre!(
                            "target triple bitmask of {} is outside of parsed range of {} targets",
                            this_func_disp!(),
                            targets.len(),
                        ));
                    }

                    // let size = reader
                    //     .read_le()
                    //     .wrap_err_with(|| eyre!("failed to read size of {}", this_func_disp!()))?;

                    let library_idx = reader.read_le::<u8>().wrap_err_with(|| {
                        eyre!("failed to read library index of {}", this_func_disp!())
                    })?;

                    let library = lib_names
                        .get(usize::from(library_idx))
                        .ok_or_else(|| {
                            eyre!(
                                "invalid library index {library_idx} of {}; expected index < {}",
                                this_func_disp!(),
                                lib_names.len(),
                            )
                        })?
                        .clone();

                    let mut inclusion_versions = Vec::new();
                    let mut version_idx_idx = 0;
                    loop {
                        const LAST_VERSION_FOR_INCLUSION_BITMASK: u8 = !(!0 >> 1);
                        let mut version_idx: u8 = reader.read_le().wrap_err_with(|| {
                            eyre!(
                                "failed to read version mapping element {version_idx_idx} of {}",
                                this_func_disp!()
                            )
                        })?;

                        let is_last_version_in_inclusion =
                            version_idx & LAST_VERSION_FOR_INCLUSION_BITMASK != 0;
                        if is_last_version_in_inclusion {
                            version_idx &= !LAST_VERSION_FOR_INCLUSION_BITMASK;
                        }

                        let version = versions
                            .get(usize::from(version_idx))
                            .ok_or_else(|| {
                                eyre!(
                                    "invalid version index {version_idx} of {}; expected index < {}",
                                    this_func_disp!(),
                                    versions.len(),
                                )
                            })?
                            .clone();

                        inclusion_versions.push(version);

                        if is_last_version_in_inclusion {
                            break;
                        }
                        version_idx_idx += 1;
                    }

                    inclusions.push(UnsizedInclusion {
                        targets_bitmask,
                        library,
                        versions: inclusion_versions.into_iter().collect(),
                    });
                    num_inclusions_found += 1;
                }

                functions.push(Function {
                    symbol_name,
                    inclusions,
                });
                num_functions_found += 1;
            }

            assert_eq!(num_inclusions_found, num_function_inclusions);

            functions
        };

        // TODO: objects

        Ok(AbiList {
            functions,
            lib_names,
            targets,
            versions,
        })
    }
}

#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
pub struct GlibcVersion {
    pub major: u8,
    pub minor: u8,
    pub patch: u8,
}

impl AbiList {
    pub fn libraries(&self) -> &[ArcStr] {
        &self.lib_names[..]
    }

    pub fn versions(&self) -> &[GlibcVersion] {
        &self.versions[..]
    }

    pub fn targets(&self) -> &[ArcStr] {
        &self.targets[..]
    }

    pub fn functions(&self) -> GlibcFunctions<'_> {
        let Self {
            targets, functions, ..
        } = self;
        GlibcFunctions { targets, functions }
    }
}

pub struct GlibcFunctions<'a> {
    targets: &'a [ArcStr],
    functions: &'a [Function],
}

impl<'a> GlibcFunctions<'a> {
    pub fn len(&self) -> u16 {
        self.functions
            .len()
            .try_into()
            .expect("internal error: length out of `u16` bounds")
    }

    pub fn iter(&self) -> impl Iterator<Item = GlibcFunction<'a>> + '_ {
        (0..self.len()).map(|idx| self.get(idx).unwrap())
    }

    pub fn get(&self, index: u16) -> Option<GlibcFunction<'a>> {
        self.functions
            .get(usize::from(index))
            .map(|func| GlibcFunction {
                targets: self.targets,
                func,
            })
    }
}

#[derive(Debug)]
pub struct Function {
    symbol_name: ArcStr,
    inclusions: Vec<UnsizedInclusion>,
}

#[derive(Debug)]
pub struct UnsizedInclusion {
    targets_bitmask: u32,
    library: ArcStr,
    versions: Vec<GlibcVersion>, // OPT: the buffer upstream is set to size `50`, maybe useful?
}

pub struct GlibcFunction<'a> {
    targets: &'a [ArcStr],
    func: &'a Function,
}

impl<'a> GlibcFunction<'a> {
    pub fn symbol_name(&self) -> &str {
        &self.func.symbol_name
    }

    pub fn inclusions(&self) -> impl Iterator<Item = GlibcFunctionInclusion<'a>> + '_ {
        self.func
            .inclusions
            .iter()
            .map(|inclusion| GlibcFunctionInclusion {
                targets: self.targets,
                inclusion,
            })
    }
}

pub struct GlibcFunctionInclusion<'a> {
    targets: &'a [ArcStr],
    inclusion: &'a UnsizedInclusion,
}

impl<'a> GlibcFunctionInclusion<'a> {
    pub fn library(&self) -> &str {
        &self.inclusion.library
    }

    pub fn versions(&self) -> &[GlibcVersion] {
        &self.inclusion.versions
    }

    pub fn targets(&self) -> impl Iterator<Item = &ArcStr> {
        (0..self.targets.len())
            .filter(|target_idx| self.inclusion.targets_bitmask & (1 << target_idx) != 0)
            .map(|target_idx| &self.targets[target_idx])
    }
}

fn parse_nul_term_ascii(
    file: &mut dyn BufRead,
    what: &dyn Display,
) -> Result<AsciiString, AbiListParseError> {
    let mut buf = Vec::new();
    file.read_until(0, &mut buf)
        .wrap_err_with(|| eyre!("failed to read {what}"))?;
    let err = |reason| eyre!("unexpected end of file while parsing {what}; {reason}");
    match buf.last() {
        Some(0) => {
            buf.pop();
        }
        Some(byte) => {
            return Err(err(format_args!(
                "expected null terminator, found {byte:02X}"
            )))
        }
        None => return Err(err(format_args!("no more bytes"))),
    };
    log::trace!("attempting to parse symbol name from {:X?}", buf);
    AsciiString::from_ascii(buf).wrap_err_with(|| eyre!("failed to parse {what} as ASCII"))
}
